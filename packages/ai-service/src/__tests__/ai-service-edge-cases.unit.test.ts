import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { AIService } from '../ai-service';
import { OpenAIProvider } from '../providers/openai';
import { ClaudeProvider } from '../providers/claude';
import { AIServiceConfig } from '../types';

/**
 * Unit Tests for AI Service Edge Cases
 * Requirements: 2.1, 2.2, 2.5
 * Test API timeout and failure scenarios
 * Test malformed input handling
 * Test rate limit exceeded scenarios
 * Test circuit breaker activation and recovery
 */

// Mock circuit breaker
const mockCircuitBreaker = {
  state: 'CLOSED',
  failureCount: 0,
  lastFailureTime: null,
  execute: vi.fn(),
  reset: vi.fn(),
  getState: vi.fn(() => 'CLOSED'),
  onStateChange: vi.fn(),
  on: vi.fn(), // Add event listener mock
  emit: vi.fn() // Add event emitter mock
};

// Mock rate limiter
const mockRateLimiter = {
  checkLimit: vi.fn(() => Promise.resolve({ allowed: true, remaining: 100 })),
  checkRequestLimit: vi.fn(() => Promise.resolve({ allowed: true, remaining: 10 })),
  checkTokenLimit: vi.fn(() => Promise.resolve({ allowed: true, remaining: 100 })),
  getRemainingTokens: vi.fn(() => 100),
  getRemainingRequests: vi.fn(() => 10)
};

vi.mock('../utils/circuit-breaker', () => ({
  CircuitBreaker: vi.fn().mockImplementation(() => mockCircuitBreaker)
}));

vi.mock('../utils/rate-limiter', () => ({
  RateLimiter: vi.fn().mockImplementation(() => mockRateLimiter)
}));

describe('AI Service Edge Cases Unit Tests', () => {
  let aiService: AIService;
  let mockConfig: AIServiceConfig;

  beforeEach(() => {
    mockConfig = {
      providers: {
        openai: {
          apiKey: 'test-openai-key',
          model: 'gpt-4-turbo-preview',
          maxTokens: 2000,
          temperature: 0.3
        },
        claude: {
          apiKey: 'test-claude-key',
          model: 'claude-3-sonnet-20240229',
          maxTokens: 2000,
          temperature: 0.3
        }
      },
      circuitBreaker: {
        failureThreshold: 3,
        resetTimeout: 5000,
        monitoringPeriod: 10000
      },
      rateLimiter: {
        tokensPerMinute: 100,
        requestsPerMinute: 10
      },
      defaultProvider: 'openai',
      fallbackProvider: 'claude'
    };

    // Reset all mocks
    vi.clearAllMocks();
    mockCircuitBreaker.state = 'CLOSED';
    mockCircuitBreaker.failureCount = 0;
    mockCircuitBreaker.getState.mockReturnValue('CLOSED');
    mockRateLimiter.checkLimit.mockResolvedValue({ allowed: true, remaining: 100 });
    mockRateLimiter.checkRequestLimit.mockResolvedValue({ allowed: true, remaining: 10 });
    mockRateLimiter.checkTokenLimit.mockResolvedValue({ allowed: true, remaining: 100 });
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('API Timeout and Failure Scenarios', () => {
    it('should handle API timeout gracefully', async () => {
      // Mock OpenAI provider to timeout
      vi.spyOn(OpenAIProvider.prototype, 'generateCode').mockImplementation(
        () => new Promise((_, reject) => {
          setTimeout(() => reject(new Error('Request timeout')), 100);
        })
      );

      // Mock Claude provider to succeed
      vi.spyOn(ClaudeProvider.prototype, 'generateCode').mockResolvedValue({
        code: 'fallback code',
        explanation: 'Generated by fallback provider',
        confidence: 0.8,
        tokensUsed: 150,
        model: 'claude-3-sonnet',
        provider: 'claude'
      });

      aiService = new AIService(mockConfig);

      const result = await aiService.generateCode('test prompt');

      expect(result.provider).toBe('claude');
      expect(result.code).toBe('fallback code');
    });

    it('should throw error when all providers fail', async () => {
      // Mock both providers to fail
      vi.spyOn(OpenAIProvider.prototype, 'generateCode').mockRejectedValue(
        new Error('OpenAI API Error')
      );
      vi.spyOn(ClaudeProvider.prototype, 'generateCode').mockRejectedValue(
        new Error('Claude API Error')
      );

      aiService = new AIService(mockConfig);

      await expect(aiService.generateCode('test prompt')).rejects.toThrow('OpenAI API Error');
    });

    it('should handle network connectivity issues', async () => {
      vi.spyOn(OpenAIProvider.prototype, 'generateCode').mockRejectedValue(
        new Error('ENOTFOUND api.openai.com')
      );
      vi.spyOn(ClaudeProvider.prototype, 'generateCode').mockResolvedValue({
        code: 'network fallback code',
        confidence: 0.7,
        tokensUsed: 120,
        model: 'claude-3-sonnet',
        provider: 'claude'
      });

      aiService = new AIService(mockConfig);

      const result = await aiService.generateCode('test prompt');
      expect(result.provider).toBe('claude');
    });
  });

  describe('Malformed Input Handling', () => {
    beforeEach(() => {
      // Mock successful responses for these tests
      vi.spyOn(OpenAIProvider.prototype, 'generateCode').mockResolvedValue({
        code: 'generated code',
        confidence: 0.9,
        tokensUsed: 100,
        model: 'gpt-4',
        provider: 'openai'
      });

      aiService = new AIService(mockConfig);
    });

    it('should handle empty prompt', async () => {
      const result = await aiService.generateCode('');
      expect(result.code).toBeDefined();
      expect(result.provider).toBe('openai');
    });

    it('should handle very long prompts', async () => {
      const longPrompt = 'a'.repeat(10000);
      const result = await aiService.generateCode(longPrompt);
      expect(result.code).toBeDefined();
    });

    it('should handle prompts with special characters', async () => {
      const specialPrompt = 'Test with special chars: !@#$%^&*()[]{}|;:,.<>?`~';
      const result = await aiService.generateCode(specialPrompt);
      expect(result.code).toBeDefined();
    });
  });

  describe('Rate Limit Exceeded Scenarios', () => {
    it('should throw rate limit error when token limit exceeded', async () => {
      const limitedConfig = {
        ...mockConfig,
        rateLimiter: {
          tokensPerMinute: 10,
          requestsPerMinute: 100
        }
      };

      // Mock rate limiter to reject after first request
      let requestCount = 0;
      mockRateLimiter.checkLimit.mockImplementation(() => {
        requestCount++;
        if (requestCount > 1) {
          return Promise.resolve({ 
            allowed: false, 
            remaining: 0,
            error: 'Token rate limit exceeded'
          });
        }
        return Promise.resolve({ allowed: true, remaining: 9 });
      });

      vi.spyOn(OpenAIProvider.prototype, 'generateCode').mockResolvedValue({
        code: 'test code',
        confidence: 0.9,
        tokensUsed: 100,
        model: 'gpt-4',
        provider: 'openai'
      });

      aiService = new AIService(limitedConfig);

      // First request should succeed
      await aiService.generateCode('short prompt');

      // Second request should fail due to token limit
      await expect(
        aiService.generateCode('another prompt', { maxTokens: 50 })
      ).rejects.toThrow(/Token rate limit exceeded/);
    });

    it('should provide accurate remaining limits', async () => {
      mockRateLimiter.getRemainingTokens.mockReturnValue(100);
      mockRateLimiter.getRemainingRequests.mockReturnValue(5);

      aiService = new AIService(mockConfig);

      const initialStatus = await aiService.getRateLimitStatus();
      expect(initialStatus?.remainingTokens).toBe(100);
      expect(initialStatus?.remainingRequests).toBe(5);
    });
  });

  describe('Circuit Breaker Activation and Recovery', () => {
    it('should activate circuit breaker after consecutive failures', async () => {
      const cbConfig = {
        ...mockConfig,
        circuitBreaker: {
          failureThreshold: 2,
          resetTimeout: 1000,
          monitoringPeriod: 5000
        }
      };

      // Mock circuit breaker to simulate state changes
      mockCircuitBreaker.execute.mockImplementation(async (fn) => {
        mockCircuitBreaker.failureCount++;
        if (mockCircuitBreaker.failureCount >= 2) {
          mockCircuitBreaker.state = 'OPEN';
          mockCircuitBreaker.getState.mockReturnValue('OPEN');
          throw new Error('Circuit breaker is OPEN');
        }
        throw new Error('API Error');
      });

      // Mock provider to always fail
      vi.spyOn(OpenAIProvider.prototype, 'generateCode').mockRejectedValue(
        new Error('API Error')
      );
      vi.spyOn(ClaudeProvider.prototype, 'generateCode').mockRejectedValue(
        new Error('API Error')
      );

      aiService = new AIService(cbConfig);

      // First failure
      await expect(aiService.generateCode('test 1')).rejects.toThrow();

      // Second failure - should trigger circuit breaker
      await expect(aiService.generateCode('test 2')).rejects.toThrow();

      // Third attempt - should fail due to circuit breaker
      mockCircuitBreaker.execute.mockRejectedValue(new Error('Circuit breaker is OPEN'));
      await expect(aiService.generateCode('test 3')).rejects.toThrow(/Circuit breaker is OPEN/);

      expect(mockCircuitBreaker.getState()).toBe('OPEN');
    });

    it('should reset circuit breakers manually', async () => {
      // Mock circuit breaker to be initially open
      mockCircuitBreaker.state = 'OPEN';
      mockCircuitBreaker.getState.mockReturnValue('OPEN');

      aiService = new AIService(mockConfig);

      // Verify circuit breaker is open
      expect(mockCircuitBreaker.getState()).toBe('OPEN');

      // Reset circuit breakers
      mockCircuitBreaker.reset.mockImplementation(() => {
        mockCircuitBreaker.state = 'CLOSED';
        mockCircuitBreaker.failureCount = 0;
        mockCircuitBreaker.getState.mockReturnValue('CLOSED');
      });

      aiService.resetCircuitBreakers();

      // Verify circuit breaker is closed
      expect(mockCircuitBreaker.reset).toHaveBeenCalled();
      expect(mockCircuitBreaker.getState()).toBe('CLOSED');
    });
  });

  describe('Provider Configuration Edge Cases', () => {
    it('should throw error when no providers configured', () => {
      const emptyConfig: AIServiceConfig = {
        providers: {},
        defaultProvider: 'openai'
      };

      expect(() => new AIService(emptyConfig)).toThrow('At least one AI provider must be configured');
    });

    it('should provide accurate provider status', () => {
      aiService = new AIService(mockConfig);

      const status = aiService.getProviderStatus();

      expect(status).toHaveProperty('openai');
      expect(status).toHaveProperty('claude');
      expect(status.openai.available).toBe(true);
      expect(status.claude.available).toBe(true);
      expect(status.openai.circuitState).toBe('CLOSED');
      expect(status.claude.circuitState).toBe('CLOSED');
    });
  });

  describe('Code Validation Edge Cases', () => {
    beforeEach(() => {
      aiService = new AIService(mockConfig);
    });

    it('should handle validation of empty code', async () => {
      vi.spyOn(OpenAIProvider.prototype, 'validateCode').mockResolvedValue({
        isValid: false,
        errors: ['Code is empty'],
        warnings: [],
        suggestions: ['Add some code']
      });

      const result = await aiService.validateCode('');
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('Code is empty');
    });

    it('should handle validation provider failures gracefully', async () => {
      vi.spyOn(OpenAIProvider.prototype, 'validateCode').mockRejectedValue(
        new Error('Validation service unavailable')
      );

      const result = await aiService.validateCode('test code');
      
      expect(result.isValid).toBe(false);
      expect(result.errors).toContain('Validation failed: Validation service unavailable');
    });
  });
});